import fs from 'fs/promises';
import path from 'path';

interface TheoremSpec {
    theorem_id: string;
    natural_language: string;
    formal_expression: string;
    context?: Record<string, any>;
    assumptions?: string[];
    variables?: Record<string, string>;
    source_module?: string;
    source_function?: string;
    priority?: 'P0' | 'P1' | 'P2' | 'P3';
}

/**
 * Translates a JSON theorem specification into a basic Lean 4 proof template.
 *
 * @param spec The theorem specification object.
 * @param mathlibImports Optional list of Mathlib libraries to import.
 * @returns A string containing the Lean 4 code template.
 */
export function translateSpecToLean(spec: TheoremSpec, mathlibImports: string[] = []): string {
    console.log(`Translating spec: ${spec.theorem_id}`);

    const imports = [
        'import Mathlib.Tactic', // Basic tactics
        // Add common imports based on potential economic/deal terms
        'import Mathlib.Data.Real.Basic', 
        'import Mathlib.Algebra.Order.Field.Basic',
        'import Mathlib.Algebra.Group.Defs',
        ...(mathlibImports || [])
    ].join('\n');

    // Generate variable declarations (basic type mapping)
    let variableDefs = ''
    if (spec.variables) {
        variableDefs = Object.entries(spec.variables)
            .map(([name, type]) => {
                // Simple type mapping - needs refinement
                let leanType = 'Real'; // Default to Real
                if (type.toLowerCase().includes('int')) {
                    leanType = 'Int';
                } else if (type.toLowerCase().includes('nat')) {
                    leanType = 'Nat';
                } else if (type.toLowerCase().includes('bool')) {
                    leanType = 'Bool';
                } else if (type.toLowerCase().includes('set')) {
                    leanType = 'Set α'; // Needs type parameter
                }
                return `variable (${name} : ${leanType})`;
            })
            .join('\n');
    }

    // Generate assumption statements
    let assumptions = '';
    if (spec.assumptions && spec.assumptions.length > 0) {
        assumptions = spec.assumptions
            .map((assumption, index) => `axiom assumption_${index + 1} : ${assumption}`)
            .join('\n');
    }

    // Construct the theorem statement
    const theoremStatement = spec.formal_expression;

    const leanCode = `
${imports}

/-!
# Theorem: ${spec.theorem_id}
Natural Language: ${spec.natural_language}
Source: ${spec.source_module || 'Unknown Module'} -> ${spec.source_function || 'Unknown Function'}
Priority: ${spec.priority || 'P3'}

Context:
${spec.context ? JSON.stringify(spec.context, null, 2) : 'None'}
-/

section ${spec.theorem_id}

-- Define variables used in the theorem
${variableDefs}

-- State assumptions as axioms for this proof context
${assumptions}

-- The theorem to be proved
theorem ${spec.theorem_id.replace('-','_')} : ${theoremStatement} := by
  sorry -- Proof skeleton generated by HMS-A2A Translator

end ${spec.theorem_id}
`;

    console.log(`Generated Lean template for ${spec.theorem_id}`);
    return leanCode;
}

/**
 * Reads a JSON specification file and generates a Lean file.
 *
 * @param jsonPath Path to the input JSON specification file.
 * @param outputDir Directory to save the generated Lean file.
 * @returns Path to the generated Lean file.
 */
export async function generateLeanFile(jsonPath: string, outputDir: string): Promise<string> {
    try {
        const specContent = await fs.readFile(jsonPath, 'utf-8');
        const spec: TheoremSpec = JSON.parse(specContent);

        // Basic validation
        if (!spec.theorem_id || !spec.natural_language || !spec.formal_expression) {
            throw new Error(`Invalid spec file: ${jsonPath}. Missing required fields.`);
        }

        const leanCode = translateSpecToLean(spec);
        const leanFileName = `${spec.theorem_id.replace('-','_')}.lean`;
        const outputPath = path.join(outputDir, leanFileName);

        await fs.mkdir(outputDir, { recursive: true });
        await fs.writeFile(outputPath, leanCode);

        console.log(`Successfully generated Lean file: ${outputPath}`);
        return outputPath;
    } catch (error) {
        console.error(`Failed to generate Lean file from ${jsonPath}:`, error);
        throw error;
    }
}

// Example Usage (can be run with ts-node)
// async function runExample() {
//     const exampleSpecPath = path.join(__dirname, '../../../schemas/example_theorem_spec.json'); // Adjust path as needed
//     const outputLeanDir = path.join(__dirname, '../../../artifacts/lean_proofs');
//     // Create dummy spec if it doesn't exist
//     if (!await fs.access(exampleSpecPath).then(() => true).catch(() => false)) {
//         const dummySpec: TheoremSpec = {
//             theorem_id: "E-01",
//             natural_language: "Walras' Law holds for generated equilibrium",
//             formal_expression: "∀ p : PriceVector, ∀ x : ExcessDemandVector, IsEquilibrium p → p ⋅ x = 0",
//             variables: { p: "PriceVector", x: "ExcessDemandVector" },
//             assumptions: ["MarketCompleteness", "RationalAgents"],
//             context: { market_id: "test_market" },
//             priority: "P0"
//         };
//         await fs.writeFile(exampleSpecPath, JSON.stringify(dummySpec, null, 2));
//         console.log(`Created dummy spec file: ${exampleSpecPath}`);
//     }
//     try {
//         await generateLeanFile(exampleSpecPath, outputLeanDir);
//     } catch (err) {
//         console.error("Example failed.");
//     }
// }
// runExample(); 