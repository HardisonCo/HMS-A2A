/**
 * Economic Fitness Functions
 * 
 * This module provides specialized fitness functions for evaluating economic
 * policy solutions generated by genetic algorithms. These functions assess
 * the effectiveness of different policy combinations for addressing various
 * economic challenges.
 */

import { HealthState } from '../monitoring/health_types';

/**
 * Economic metric types for fitness evaluation.
 */
export enum EconomicMetric {
  GDPGrowth = 'gdp_growth',
  Inflation = 'inflation',
  Unemployment = 'unemployment',
  TradeBalance = 'trade_balance',
  BudgetDeficit = 'budget_deficit',
  PublicDebt = 'public_debt',
  IncomeInequality = 'income_inequality',
  ProductivityGrowth = 'productivity_growth',
  LaborForceParticipation = 'labor_force_participation',
  RealWageGrowth = 'real_wage_growth',
  BusinessInvestment = 'business_investment',
  ConsumerConfidence = 'consumer_confidence',
  FinancialStability = 'financial_stability',
  EnvironmentalSustainability = 'environmental_sustainability',
  InfrastructureQuality = 'infrastructure_quality',
  CapacityUtilization = 'capacity_utilization',
  EconomicComplexity = 'economic_complexity',
  InnovationIndex = 'innovation_index',
  HumanCapitalIndex = 'human_capital_index',
  SupplyChainResilience = 'supply_chain_resilience'
}

/**
 * Economic scenario types for fitness evaluation.
 */
export enum EconomicScenario {
  Stagflation = 'stagflation',
  RecessionRisk = 'recession_risk',
  OverheatingEconomy = 'overheating_economy',
  TradeWar = 'trade_war',
  PandemicRecovery = 'pandemic_recovery',
  SupplyChainDisruption = 'supply_chain_disruption',
  TechnologicalDisruption = 'technological_disruption',
  CurrencyCrisis = 'currency_crisis',
  AssetBubble = 'asset_bubble',
  FinancialCrisis = 'financial_crisis',
  SovereignDebtCrisis = 'sovereign_debt_crisis',
  DeflationarySpiral = 'deflationary_spiral',
  StructuralTransformation = 'structural_transformation',
  DemographicShift = 'demographic_shift',
  ClimateTransition = 'climate_transition',
  NaturalDisaster = 'natural_disaster',
  GeopoliticalCrisis = 'geopolitical_crisis'
}

/**
 * Policy parameter types for fitness evaluation.
 */
export enum PolicyParameterType {
  InterestRate = 'interest_rate',
  FiscalStimulus = 'fiscal_stimulus',
  TaxRate = 'tax_rate',
  GovernmentSpending = 'government_spending',
  TariffRate = 'tariff_rate',
  TradeAgreement = 'trade_agreement',
  SupplyChainPolicy = 'supply_chain_policy',
  RegulatoryPolicy = 'regulatory_policy',
  MonetaryPolicy = 'monetary_policy',
  LaborMarketPolicy = 'labor_market_policy',
  InfrastructureInvestment = 'infrastructure_investment',
  InnovationPolicy = 'innovation_policy',
  EnvironmentalPolicy = 'environmental_policy',
  SocialSafetyNet = 'social_safety_net',
  EducationTraining = 'education_training',
  IndustrialPolicy = 'industrial_policy',
  CompetitionPolicy = 'competition_policy',
  FinancialRegulation = 'financial_regulation',
  HealthcarePolicy = 'healthcare_policy',
  PensionPolicy = 'pension_policy'
}

/**
 * Time horizon for fitness evaluation.
 */
export enum TimeHorizon {
  Immediate = 'immediate', // 0-3 months
  ShortTerm = 'short_term', // 3-12 months
  MediumTerm = 'medium_term', // 1-3 years
  LongTerm = 'long_term', // 3-10 years
  VeryLongTerm = 'very_long_term' // 10+ years
}

/**
 * Weights configuration for multi-objective fitness evaluation.
 */
export interface FitnessWeights {
  gdpGrowth?: number;
  inflation?: number;
  unemployment?: number; 
  tradeBalance?: number;
  budgetDeficit?: number;
  publicDebt?: number;
  incomeInequality?: number;
  productivityGrowth?: number;
  laborForceParticipation?: number;
  realWageGrowth?: number;
  businessInvestment?: number;
  consumerConfidence?: number;
  financialStability?: number;
  environmentalSustainability?: number;
  infrastructureQuality?: number;
  capacityUtilization?: number;
  economicComplexity?: number;
  innovationIndex?: number;
  humanCapitalIndex?: number;
  supplyChainResilience?: number;
  implementationFeasibility?: number;
  politicalAcceptability?: number;
  administrativeComplexity?: number;
  redistributiveImpact?: number;
  structuralReform?: number;
  timeConsistency?: number;
  policyCoherence?: number;
  internationalCoordination?: number;
}

/**
 * Model parameters for fitness evaluation.
 */
export interface ModelParameters {
  // Macroeconomic parameters
  potentialGrowthRate?: number;
  naturalUnemploymentRate?: number;
  inflationTarget?: number;
  neutralInterestRate?: number;
  fiscalMultiplier?: number;
  publicDebtSustainabilityThreshold?: number;
  
  // Trade parameters
  tradePriceElasticity?: number;
  tradeIncomeElasticity?: number;
  tariffEffectiveness?: number;
  exchangeRateSensitivity?: number;
  
  // Policy lag parameters
  monetaryPolicyLag?: number;
  fiscalPolicyLag?: number;
  structuralPolicyLag?: number;
  
  // Structural parameters
  laborMarketFlexibility?: number;
  productMarketRegulation?: number;
  economicComplexityIndex?: number;
  
  // Financial parameters
  financialCycleSensitivity?: number;
  capitalFlowSensitivity?: number;
  financialMarketEfficiency?: number;
  
  // External parameters
  globalGrowthRate?: number;
  globalInflationRate?: number;
  commodityPriceGrowth?: number;
  demographicTrend?: number;
  technologyTrend?: number;
  climateChangeTrend?: number;
}

/**
 * Economic state for fitness evaluation.
 */
export interface EconomicState {
  // Core economic indicators
  gdpGrowth: number;
  inflation: number;
  unemployment: number;
  
  // Fiscal indicators
  budgetBalancePercGDP: number;
  publicDebtPercGDP: number;
  
  // Monetary indicators
  interestRate: number;
  moneySupplyGrowth: number;
  
  // External indicators
  tradeBalancePercGDP: number;
  currentAccountPercGDP: number;
  exchangeRateIndex: number;
  
  // Real economy indicators
  industrialProduction: number;
  capacityUtilization: number;
  retailSales: number;
  consumerConfidence: number;
  businessConfidence: number;
  
  // Labor market indicators
  laborForceParticipation: number;
  employmentRate: number;
  wageGrowth: number;
  
  // Financial indicators
  stockMarketIndex: number;
  corporateCreditGrowth: number;
  householdCreditGrowth: number;
  bankingSystemHealth: number;
  
  // Structural indicators
  productivityGrowth: number;
  incomeInequality: number;
  povertyRate: number;
  humanCapitalIndex: number;
  
  // External context
  globalGrowthRate: number;
  globalInflationRate: number;
  geopoliticalRiskIndex: number;
  commodityPriceIndex: number;
  
  // Extra indicators for specific scenarios
  extraIndicators?: Record<string, number>;
}

/**
 * Options for fitness function.
 */
export interface FitnessOptions {
  // Objectives and weights
  primaryObjective?: EconomicMetric;
  secondaryObjectives?: EconomicMetric[];
  weights?: FitnessWeights;
  
  // Time preferences
  timeHorizon?: TimeHorizon;
  discountRate?: number;
  
  // Constraints
  hardConstraints?: Array<{
    metric: EconomicMetric;
    min?: number;
    max?: number;
  }>;
  
  // Model configuration
  modelParameters?: ModelParameters;
  
  // Scenario specifics
  scenario?: EconomicScenario;
  shockMagnitude?: number;
  
  // Implementation considerations
  considerPoliticalFeasibility?: boolean;
  considerImplementationCosts?: boolean;
  considerDistributionalEffects?: boolean;
  
  // Additional settings
  useHistoricalData?: boolean;
  useMonteCarlo?: boolean;
  monteCarloIterations?: number;
  useExpectationFormation?: boolean;
  
  // Advanced options
  useAiAmplification?: boolean;
  useDynamicModel?: boolean;
  spatialDimension?: 'national' | 'regional' | 'global';
  sectoralDetail?: 'aggregate' | 'main_sectors' | 'detailed';
}

/**
 * Result of a fitness evaluation.
 */
export interface FitnessResult {
  // Primary results
  fitness: number;
  normalizedFitness: number; // 0-1 scale
  objectiveValues: Record<EconomicMetric, number>;
  
  // Projected economic outcomes
  projectedState: EconomicState;
  
  // Time analysis
  shortTermEffects: Record<EconomicMetric, number>;
  mediumTermEffects: Record<EconomicMetric, number>;
  longTermEffects: Record<EconomicMetric, number>;
  
  // Risk assessment
  riskAnalysis: {
    downside: Record<EconomicMetric, number>;
    upside: Record<EconomicMetric, number>;
    volatility: Record<EconomicMetric, number>;
  };
  
  // Feasibility assessment
  implementationFeasibility: number;
  politicalFeasibility: number;
  administrativeComplexity: number;
  
  // Comparison to baseline
  improvementOverBaseline: Record<EconomicMetric, number>;
  
  // Detailed analysis
  tradeoffs: Array<{
    metricImproved: EconomicMetric;
    metricWorsened: EconomicMetric;
    magnitude: number;
  }>;
  
  // Constraint violations
  constraintViolations: Array<{
    metric: EconomicMetric;
    value: number;
    threshold: number;
    violationType: 'min' | 'max';
  }>;
  
  // Monte Carlo results (if enabled)
  confidenceIntervals?: Record<EconomicMetric, [number, number]>;
  probabilityOfSuccess?: number;
  
  // Analysis log
  log: string[];
}

/**
 * Interface for economic fitness function.
 */
export interface EconomicFitnessFunction {
  /**
   * Evaluates the fitness of a policy solution.
   * 
   * @param solution The policy solution to evaluate
   * @param initialState The initial economic state
   * @param options Evaluation options
   * @returns The fitness result
   */
  evaluate: (
    solution: Record<string, any>,
    initialState: EconomicState,
    options?: FitnessOptions
  ) => Promise<FitnessResult>;
  
  /**
   * Gets the name of the fitness function.
   * 
   * @returns The name
   */
  getName: () => string;
  
  /**
   * Gets the description of the fitness function.
   * 
   * @returns The description
   */
  getDescription: () => string;
  
  /**
   * Gets the required parameters for the fitness function.
   * 
   * @returns The required parameters
   */
  getRequiredParameters: () => string[];
  
  /**
   * Gets the optional parameters for the fitness function.
   * 
   * @returns The optional parameters
   */
  getOptionalParameters: () => string[];
  
  /**
   * Gets the supported scenarios for the fitness function.
   * 
   * @returns The supported scenarios
   */
  getSupportedScenarios: () => EconomicScenario[];
  
  /**
   * Gets the default options for the fitness function.
   * 
   * @returns The default options
   */
  getDefaultOptions: () => FitnessOptions;
}

/**
 * Registry for economic fitness functions.
 */
export class EconomicFitnessFunctionRegistry {
  private static instance: EconomicFitnessFunctionRegistry;
  private fitnessFunctions: Map<string, EconomicFitnessFunction> = new Map();
  private isInitialized: boolean = false;
  
  /**
   * Gets the singleton instance of the registry.
   * 
   * @returns The registry instance
   */
  public static getInstance(): EconomicFitnessFunctionRegistry {
    if (!EconomicFitnessFunctionRegistry.instance) {
      EconomicFitnessFunctionRegistry.instance = new EconomicFitnessFunctionRegistry();
    }
    
    return EconomicFitnessFunctionRegistry.instance;
  }
  
  /**
   * Private constructor to enforce singleton pattern.
   */
  private constructor() {}
  
  /**
   * Initializes the registry.
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    console.log('Initializing Economic Fitness Function Registry...');
    
    // Register built-in fitness functions
    this.registerBuiltInFunctions();
    
    this.isInitialized = true;
    console.log('Economic Fitness Function Registry initialized successfully');
  }
  
  /**
   * Registers a fitness function.
   * 
   * @param name The name of the fitness function
   * @param fitnessFunction The fitness function
   */
  public register(name: string, fitnessFunction: EconomicFitnessFunction): void {
    if (this.fitnessFunctions.has(name)) {
      console.warn(`Fitness function "${name}" is already registered. Overwriting...`);
    }
    
    this.fitnessFunctions.set(name, fitnessFunction);
    console.log(`Registered fitness function: ${name}`);
  }
  
  /**
   * Gets a fitness function by name.
   * 
   * @param name The name of the fitness function
   * @returns The fitness function
   */
  public get(name: string): EconomicFitnessFunction {
    if (!this.fitnessFunctions.has(name)) {
      throw new Error(`Fitness function "${name}" not found`);
    }
    
    return this.fitnessFunctions.get(name)!;
  }
  
  /**
   * Checks if a fitness function exists.
   * 
   * @param name The name of the fitness function
   * @returns True if the fitness function exists
   */
  public has(name: string): boolean {
    return this.fitnessFunctions.has(name);
  }
  
  /**
   * Lists all registered fitness functions.
   * 
   * @returns List of fitness function names
   */
  public list(): Array<{
    name: string;
    description: string;
    supportedScenarios: EconomicScenario[];
  }> {
    return Array.from(this.fitnessFunctions.entries()).map(([name, func]) => ({
      name,
      description: func.getDescription(),
      supportedScenarios: func.getSupportedScenarios()
    }));
  }
  
  /**
   * Gets health status information.
   * 
   * @returns Health status
   */
  public getHealthStatus(): any {
    return {
      component: "economic_fitness_function_registry",
      state: this.isInitialized ? HealthState.Healthy : HealthState.Unhealthy,
      message: this.isInitialized ? 
        "Economic Fitness Function Registry is healthy" : 
        "Economic Fitness Function Registry is not initialized",
      timestamp: new Date().toISOString(),
      details: {
        initialized: this.isInitialized,
        registeredFunctions: this.fitnessFunctions.size,
        functionNames: Array.from(this.fitnessFunctions.keys())
      }
    };
  }
  
  /**
   * Registers built-in fitness functions.
   */
  private registerBuiltInFunctions(): void {
    // Register stagflation mitigation fitness function
    this.register('stagflation_mitigation', createStagflationMitigationFunction());
    
    // Register trade balance optimization fitness function
    this.register('trade_balance_optimization', createTradeBalanceOptimizationFunction());
    
    // Register fiscal policy optimization fitness function
    this.register('fiscal_policy_optimization', createFiscalPolicyOptimizationFunction());
    
    // Register monetary policy optimization fitness function
    this.register('monetary_policy_optimization', createMonetaryPolicyOptimizationFunction());
    
    // Register inflation targeting fitness function
    this.register('inflation_targeting', createInflationTargetingFunction());
    
    // Register labor market optimization fitness function
    this.register('labor_market_optimization', createLaborMarketOptimizationFunction());
    
    // Register economic growth maximization fitness function
    this.register('economic_growth_maximization', createEconomicGrowthMaximizationFunction());
    
    // Register supply shock resilience fitness function
    this.register('supply_shock_resilience', createSupplyShockResilienceFunction());
  }
}

/**
 * Creates a new stagflation mitigation fitness function.
 * 
 * @returns Stagflation mitigation fitness function
 */
function createStagflationMitigationFunction(): EconomicFitnessFunction {
  const name = 'stagflation_mitigation';
  const description = 'Evaluates policy effectiveness in addressing stagflation (high inflation with slow growth and high unemployment)';
  
  const requiredParameters = [
    'interest_rate_adjustment',
    'fiscal_stimulus_percentage',
    'supply_side_reform_intensity'
  ];
  
  const optionalParameters = [
    'commodity_reserve_release',
    'targeted_sector_count',
    'income_support_threshold',
    'policy_sequencing'
  ];
  
  const supportedScenarios = [
    EconomicScenario.Stagflation,
    EconomicScenario.SupplyChainDisruption,
    EconomicScenario.GeopoliticalCrisis
  ];
  
  const defaultOptions: FitnessOptions = {
    primaryObjective: EconomicMetric.Inflation,
    secondaryObjectives: [
      EconomicMetric.Unemployment, 
      EconomicMetric.GDPGrowth,
      EconomicMetric.ProductivityGrowth
    ],
    weights: {
      inflation: 0.4,
      unemployment: 0.3,
      gdpGrowth: 0.2,
      productivityGrowth: 0.1
    },
    timeHorizon: TimeHorizon.MediumTerm,
    discountRate: 0.05,
    hardConstraints: [
      {
        metric: EconomicMetric.Inflation,
        max: 8.0 // Cap inflation at 8%
      },
      {
        metric: EconomicMetric.Unemployment,
        max: 10.0 // Cap unemployment at 10%
      }
    ],
    modelParameters: {
      potentialGrowthRate: 2.0,
      naturalUnemploymentRate: 4.5,
      inflationTarget: 2.0,
      neutralInterestRate: 2.5,
      fiscalMultiplier: 0.8,
      monetaryPolicyLag: 3,
      fiscalPolicyLag: 2,
      structuralPolicyLag: 8
    },
    scenario: EconomicScenario.Stagflation,
    shockMagnitude: 1.0,
    considerPoliticalFeasibility: true,
    considerImplementationCosts: true,
    considerDistributionalEffects: true
  };
  
  /**
   * Evaluates the fitness of a policy solution for stagflation mitigation.
   * 
   * @param solution The policy solution to evaluate
   * @param initialState The initial economic state
   * @param options Evaluation options
   * @returns The fitness result
   */
  const evaluate = async (
    solution: Record<string, any>,
    initialState: EconomicState,
    options: FitnessOptions = {}
  ): Promise<FitnessResult> => {
    // Merge options with defaults
    const mergedOptions = { ...defaultOptions, ...options };
    
    // Extract solution parameters
    const interestRateAdjustment = solution.interest_rate_adjustment || 0;
    const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
    const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
    const commodityReserveRelease = solution.commodity_reserve_release || 0;
    const targetedSectorCount = solution.targeted_sector_count || 0;
    
    // Analysis log
    const log: string[] = [];
    log.push(`Evaluating stagflation mitigation policy solution`);
    log.push(`Interest rate adjustment: ${interestRateAdjustment}%`);
    log.push(`Fiscal stimulus: ${fiscalStimulusPercentage}% of GDP`);
    log.push(`Supply-side reform intensity: ${supplySideReformIntensity} (0-10 scale)`);
    
    // Calculate short-term effects (0-12 months)
    const shortTermEffects = calculateStagflationShortTermEffects(
      solution,
      initialState,
      mergedOptions
    );
    
    // Calculate medium-term effects (1-3 years)
    const mediumTermEffects = calculateStagflationMediumTermEffects(
      solution,
      initialState,
      shortTermEffects,
      mergedOptions
    );
    
    // Calculate long-term effects (3-10 years)
    const longTermEffects = calculateStagflationLongTermEffects(
      solution,
      initialState,
      mediumTermEffects,
      mergedOptions
    );
    
    // Calculate overall effects based on time horizon
    const timeHorizonWeights = getTimeHorizonWeights(mergedOptions.timeHorizon || TimeHorizon.MediumTerm);
    const objectiveValues: Record<EconomicMetric, number> = {
      [EconomicMetric.GDPGrowth]: 
        shortTermEffects.gdpGrowth * timeHorizonWeights.shortTerm +
        mediumTermEffects.gdpGrowth * timeHorizonWeights.mediumTerm +
        longTermEffects.gdpGrowth * timeHorizonWeights.longTerm,
      
      [EconomicMetric.Inflation]:
        shortTermEffects.inflation * timeHorizonWeights.shortTerm +
        mediumTermEffects.inflation * timeHorizonWeights.mediumTerm +
        longTermEffects.inflation * timeHorizonWeights.longTerm,
      
      [EconomicMetric.Unemployment]:
        shortTermEffects.unemployment * timeHorizonWeights.shortTerm +
        mediumTermEffects.unemployment * timeHorizonWeights.mediumTerm +
        longTermEffects.unemployment * timeHorizonWeights.longTerm,
      
      [EconomicMetric.ProductivityGrowth]:
        shortTermEffects.productivityGrowth * timeHorizonWeights.shortTerm +
        mediumTermEffects.productivityGrowth * timeHorizonWeights.mediumTerm +
        longTermEffects.productivityGrowth * timeHorizonWeights.longTerm,
      
      // Set other metrics to default values or calculated values
      [EconomicMetric.TradeBalance]: 0,
      [EconomicMetric.BudgetDeficit]: -fiscalStimulusPercentage,
      [EconomicMetric.PublicDebt]: initialState.publicDebtPercGDP + fiscalStimulusPercentage,
      [EconomicMetric.IncomeInequality]: initialState.incomeInequality,
      [EconomicMetric.LaborForceParticipation]: initialState.laborForceParticipation,
      [EconomicMetric.RealWageGrowth]: initialState.wageGrowth - shortTermEffects.inflation,
      [EconomicMetric.BusinessInvestment]: initialState.businessConfidence,
      [EconomicMetric.ConsumerConfidence]: initialState.consumerConfidence,
      [EconomicMetric.FinancialStability]: initialState.bankingSystemHealth,
      [EconomicMetric.EnvironmentalSustainability]: 0,
      [EconomicMetric.InfrastructureQuality]: initialState.extraIndicators?.infrastructureQuality || 0,
      [EconomicMetric.CapacityUtilization]: initialState.capacityUtilization,
      [EconomicMetric.EconomicComplexity]: initialState.extraIndicators?.economicComplexity || 0,
      [EconomicMetric.InnovationIndex]: initialState.extraIndicators?.innovationIndex || 0,
      [EconomicMetric.HumanCapitalIndex]: initialState.humanCapitalIndex,
      [EconomicMetric.SupplyChainResilience]: initialState.extraIndicators?.supplyChainResilience || 0
    };
    
    // Calculate fitness based on objective values and weights
    let fitness = 0;
    const weights = mergedOptions.weights || {};
    
    // Calculate weighted sum of objectives
    if (weights.inflation !== undefined) {
      fitness += weights.inflation * (1 - Math.abs(objectiveValues[EconomicMetric.Inflation] - 
                              (mergedOptions.modelParameters?.inflationTarget || 2.0)) / 10);
    }
    
    if (weights.unemployment !== undefined) {
      fitness += weights.unemployment * (1 - Math.abs(objectiveValues[EconomicMetric.Unemployment] - 
                              (mergedOptions.modelParameters?.naturalUnemploymentRate || 4.5)) / 10);
    }
    
    if (weights.gdpGrowth !== undefined) {
      fitness += weights.gdpGrowth * (objectiveValues[EconomicMetric.GDPGrowth] / 
                               (mergedOptions.modelParameters?.potentialGrowthRate || 2.0));
    }
    
    if (weights.productivityGrowth !== undefined) {
      fitness += weights.productivityGrowth * (objectiveValues[EconomicMetric.ProductivityGrowth] / 
                                      (mergedOptions.modelParameters?.potentialGrowthRate || 2.0));
    }
    
    // Apply penalty for hard constraint violations
    const constraintViolations: Array<{
      metric: EconomicMetric;
      value: number;
      threshold: number;
      violationType: 'min' | 'max';
    }> = [];
    
    if (mergedOptions.hardConstraints) {
      for (const constraint of mergedOptions.hardConstraints) {
        const value = objectiveValues[constraint.metric];
        
        if (constraint.max !== undefined && value > constraint.max) {
          constraintViolations.push({
            metric: constraint.metric,
            value,
            threshold: constraint.max,
            violationType: 'max'
          });
          
          // Apply penalty
          fitness -= 0.2 * (value - constraint.max) / constraint.max;
        }
        
        if (constraint.min !== undefined && value < constraint.min) {
          constraintViolations.push({
            metric: constraint.metric,
            value,
            threshold: constraint.min,
            violationType: 'min'
          });
          
          // Apply penalty
          fitness -= 0.2 * (constraint.min - value) / constraint.min;
        }
      }
    }
    
    // Calculate implementation feasibility (0-1 scale)
    const implementationFeasibility = calculateImplementationFeasibility(solution, mergedOptions);
    
    // Calculate political feasibility (0-1 scale)
    const politicalFeasibility = calculatePoliticalFeasibility(solution, objectiveValues, mergedOptions);
    
    // Calculate administrative complexity (0-1 scale, lower is better)
    const administrativeComplexity = calculateAdministrativeComplexity(solution, mergedOptions);
    
    // Apply implementation concerns if enabled
    if (mergedOptions.considerImplementationCosts) {
      fitness *= (0.7 + 0.3 * (1 - administrativeComplexity));
    }
    
    if (mergedOptions.considerPoliticalFeasibility) {
      fitness *= (0.7 + 0.3 * politicalFeasibility);
    }
    
    // Apply additional penalty for extreme policy values
    if (Math.abs(interestRateAdjustment) > 3) {
      fitness *= 0.9; // 10% penalty for extreme interest rate changes
    }
    
    if (fiscalStimulusPercentage > 5) {
      fitness *= 0.9; // 10% penalty for extreme fiscal stimulus
    }
    
    // Calculate normalized fitness (0-1 scale)
    const normalizedFitness = Math.max(0, Math.min(1, fitness));
    
    // Calculate projected economic state
    const projectedState: EconomicState = {
      ...initialState,
      gdpGrowth: objectiveValues[EconomicMetric.GDPGrowth],
      inflation: objectiveValues[EconomicMetric.Inflation],
      unemployment: objectiveValues[EconomicMetric.Unemployment],
      budgetBalancePercGDP: initialState.budgetBalancePercGDP - fiscalStimulusPercentage,
      publicDebtPercGDP: initialState.publicDebtPercGDP + fiscalStimulusPercentage,
      interestRate: initialState.interestRate + interestRateAdjustment,
      productivityGrowth: objectiveValues[EconomicMetric.ProductivityGrowth],
      capacityUtilization: shortTermEffects.capacityUtilization
    };
    
    // Calculate improvement over baseline for each metric
    const improvementOverBaseline: Record<EconomicMetric, number> = {
      [EconomicMetric.Inflation]: initialState.inflation - objectiveValues[EconomicMetric.Inflation],
      [EconomicMetric.Unemployment]: initialState.unemployment - objectiveValues[EconomicMetric.Unemployment],
      [EconomicMetric.GDPGrowth]: objectiveValues[EconomicMetric.GDPGrowth] - initialState.gdpGrowth,
      [EconomicMetric.ProductivityGrowth]: objectiveValues[EconomicMetric.ProductivityGrowth] - initialState.productivityGrowth,
      [EconomicMetric.TradeBalance]: 0,
      [EconomicMetric.BudgetDeficit]: 0,
      [EconomicMetric.PublicDebt]: 0,
      [EconomicMetric.IncomeInequality]: 0,
      [EconomicMetric.LaborForceParticipation]: 0,
      [EconomicMetric.RealWageGrowth]: 0,
      [EconomicMetric.BusinessInvestment]: 0,
      [EconomicMetric.ConsumerConfidence]: 0,
      [EconomicMetric.FinancialStability]: 0,
      [EconomicMetric.EnvironmentalSustainability]: 0,
      [EconomicMetric.InfrastructureQuality]: 0,
      [EconomicMetric.CapacityUtilization]: 0,
      [EconomicMetric.EconomicComplexity]: 0,
      [EconomicMetric.InnovationIndex]: 0,
      [EconomicMetric.HumanCapitalIndex]: 0,
      [EconomicMetric.SupplyChainResilience]: 0
    };
    
    // Calculate tradeoffs
    const tradeoffs: Array<{
      metricImproved: EconomicMetric;
      metricWorsened: EconomicMetric;
      magnitude: number;
    }> = [];
    
    // Add tradeoff between inflation and growth
    if (improvementOverBaseline[EconomicMetric.Inflation] > 0 &&
        improvementOverBaseline[EconomicMetric.GDPGrowth] < 0) {
      tradeoffs.push({
        metricImproved: EconomicMetric.Inflation,
        metricWorsened: EconomicMetric.GDPGrowth,
        magnitude: Math.min(
          Math.abs(improvementOverBaseline[EconomicMetric.Inflation]),
          Math.abs(improvementOverBaseline[EconomicMetric.GDPGrowth])
        )
      });
    }
    
    // Add tradeoff between budget deficit and growth
    if (fiscalStimulusPercentage > 0 &&
        improvementOverBaseline[EconomicMetric.GDPGrowth] > 0) {
      tradeoffs.push({
        metricImproved: EconomicMetric.GDPGrowth,
        metricWorsened: EconomicMetric.BudgetDeficit,
        magnitude: fiscalStimulusPercentage / 2
      });
    }
    
    // Calculate risk analysis
    const riskAnalysis = {
      downside: {
        [EconomicMetric.GDPGrowth]: objectiveValues[EconomicMetric.GDPGrowth] - 1.0,
        [EconomicMetric.Inflation]: objectiveValues[EconomicMetric.Inflation] + 1.0,
        [EconomicMetric.Unemployment]: objectiveValues[EconomicMetric.Unemployment] + 0.5
      } as Record<EconomicMetric, number>,
      upside: {
        [EconomicMetric.GDPGrowth]: objectiveValues[EconomicMetric.GDPGrowth] + 0.5,
        [EconomicMetric.Inflation]: objectiveValues[EconomicMetric.Inflation] - 0.5,
        [EconomicMetric.Unemployment]: objectiveValues[EconomicMetric.Unemployment] - 0.3
      } as Record<EconomicMetric, number>,
      volatility: {
        [EconomicMetric.GDPGrowth]: 0.5,
        [EconomicMetric.Inflation]: 0.8,
        [EconomicMetric.Unemployment]: 0.3
      } as Record<EconomicMetric, number>
    };
    
    // Log completion
    log.push(`Evaluation complete. Fitness: ${normalizedFitness.toFixed(4)}`);
    
    return {
      fitness,
      normalizedFitness,
      objectiveValues,
      projectedState,
      shortTermEffects: {
        [EconomicMetric.GDPGrowth]: shortTermEffects.gdpGrowth,
        [EconomicMetric.Inflation]: shortTermEffects.inflation,
        [EconomicMetric.Unemployment]: shortTermEffects.unemployment,
        [EconomicMetric.ProductivityGrowth]: shortTermEffects.productivityGrowth
      } as Record<EconomicMetric, number>,
      mediumTermEffects: {
        [EconomicMetric.GDPGrowth]: mediumTermEffects.gdpGrowth,
        [EconomicMetric.Inflation]: mediumTermEffects.inflation,
        [EconomicMetric.Unemployment]: mediumTermEffects.unemployment,
        [EconomicMetric.ProductivityGrowth]: mediumTermEffects.productivityGrowth
      } as Record<EconomicMetric, number>,
      longTermEffects: {
        [EconomicMetric.GDPGrowth]: longTermEffects.gdpGrowth,
        [EconomicMetric.Inflation]: longTermEffects.inflation,
        [EconomicMetric.Unemployment]: longTermEffects.unemployment,
        [EconomicMetric.ProductivityGrowth]: longTermEffects.productivityGrowth
      } as Record<EconomicMetric, number>,
      riskAnalysis,
      implementationFeasibility,
      politicalFeasibility,
      administrativeComplexity,
      improvementOverBaseline,
      tradeoffs,
      constraintViolations,
      log
    };
  };
  
  return {
    evaluate,
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => requiredParameters,
    getOptionalParameters: () => optionalParameters,
    getSupportedScenarios: () => supportedScenarios,
    getDefaultOptions: () => defaultOptions
  };
}

/**
 * Creates a new trade balance optimization fitness function.
 * 
 * @returns Trade balance optimization fitness function
 */
function createTradeBalanceOptimizationFunction(): EconomicFitnessFunction {
  const name = 'trade_balance_optimization';
  const description = 'Evaluates policy effectiveness in optimizing trade balance while minimizing negative economic impacts';
  
  const requiredParameters = [
    'tariff_rate_adjustment',
    'export_incentive_percentage',
    'supply_chain_resilience_investment'
  ];
  
  const optionalParameters = [
    'strategic_sectors_count',
    'trade_agreement_approach'
  ];
  
  const supportedScenarios = [
    EconomicScenario.TradeWar,
    EconomicScenario.SupplyChainDisruption,
    EconomicScenario.GeopoliticalCrisis,
    EconomicScenario.CurrencyCrisis
  ];
  
  const defaultOptions: FitnessOptions = {
    primaryObjective: EconomicMetric.TradeBalance,
    secondaryObjectives: [
      EconomicMetric.GDPGrowth,
      EconomicMetric.Inflation,
      EconomicMetric.SupplyChainResilience
    ],
    weights: {
      tradeBalance: 0.5,
      gdpGrowth: 0.2,
      inflation: 0.1,
      supplyChainResilience: 0.2
    },
    timeHorizon: TimeHorizon.MediumTerm,
    hardConstraints: [
      {
        metric: EconomicMetric.GDPGrowth,
        min: 1.0 // Minimum GDP growth of 1%
      }
    ],
    scenario: EconomicScenario.TradeWar,
    considerPoliticalFeasibility: true,
    considerImplementationCosts: true
  };
  
  /**
   * Evaluates the fitness of a policy solution for trade balance optimization.
   * 
   * @param solution The policy solution to evaluate
   * @param initialState The initial economic state
   * @param options Evaluation options
   * @returns The fitness result
   */
  const evaluate = async (
    solution: Record<string, any>,
    initialState: EconomicState,
    options: FitnessOptions = {}
  ): Promise<FitnessResult> => {
    // Implementation is similar to stagflation mitigation, but focused on trade balance
    // For brevity, this is a simplified implementation
    
    // Extract solution parameters
    const tariffRateAdjustment = solution.tariff_rate_adjustment || 0;
    const exportIncentivePercentage = solution.export_incentive_percentage || 0;
    const supplyChainInvestment = solution.supply_chain_resilience_investment || 0;
    
    // Simulate evaluation result
    return {
      fitness: 0.75, // Sample value
      normalizedFitness: 0.75,
      objectiveValues: {
        [EconomicMetric.TradeBalance]: initialState.tradeBalancePercGDP + 1.5,
        [EconomicMetric.GDPGrowth]: initialState.gdpGrowth - 0.2,
        [EconomicMetric.Inflation]: initialState.inflation + 0.3,
        [EconomicMetric.Unemployment]: initialState.unemployment,
        [EconomicMetric.SupplyChainResilience]: initialState.extraIndicators?.supplyChainResilience || 0 + supplyChainInvestment * 5,
      } as Record<EconomicMetric, number>,
      projectedState: initialState,
      shortTermEffects: {} as Record<EconomicMetric, number>,
      mediumTermEffects: {} as Record<EconomicMetric, number>,
      longTermEffects: {} as Record<EconomicMetric, number>,
      riskAnalysis: {
        downside: {} as Record<EconomicMetric, number>,
        upside: {} as Record<EconomicMetric, number>,
        volatility: {} as Record<EconomicMetric, number>
      },
      implementationFeasibility: 0.8,
      politicalFeasibility: 0.6,
      administrativeComplexity: 0.4,
      improvementOverBaseline: {} as Record<EconomicMetric, number>,
      tradeoffs: [],
      constraintViolations: [],
      log: ['Trade balance optimization evaluation completed']
    };
  };
  
  return {
    evaluate,
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => requiredParameters,
    getOptionalParameters: () => optionalParameters,
    getSupportedScenarios: () => supportedScenarios,
    getDefaultOptions: () => defaultOptions
  };
}

/**
 * Creates a new fiscal policy optimization fitness function.
 * 
 * @returns Fiscal policy optimization fitness function
 */
function createFiscalPolicyOptimizationFunction(): EconomicFitnessFunction {
  const name = 'fiscal_policy_optimization';
  const description = 'Evaluates policy effectiveness in optimizing fiscal policy for economic growth and sustainability';
  
  const requiredParameters = [
    'tax_rate_adjustment',
    'spending_adjustment_percentage',
    'infrastructure_investment'
  ];
  
  const optionalParameters = [
    'debt_target_adjustment',
    'policy_phase_in_years'
  ];
  
  const supportedScenarios = [
    EconomicScenario.RecessionRisk,
    EconomicScenario.SovereignDebtCrisis,
    EconomicScenario.StructuralTransformation
  ];
  
  const defaultOptions: FitnessOptions = {
    primaryObjective: EconomicMetric.BudgetDeficit,
    secondaryObjectives: [
      EconomicMetric.GDPGrowth,
      EconomicMetric.PublicDebt,
      EconomicMetric.Unemployment
    ],
    weights: {
      budgetDeficit: 0.4,
      gdpGrowth: 0.3,
      publicDebt: 0.2,
      unemployment: 0.1
    },
    timeHorizon: TimeHorizon.LongTerm,
    hardConstraints: [
      {
        metric: EconomicMetric.PublicDebt,
        max: 100.0 // Maximum public debt of 100% of GDP
      }
    ],
    scenario: EconomicScenario.StructuralTransformation,
    considerPoliticalFeasibility: true,
    considerDistributionalEffects: true
  };
  
  /**
   * Evaluates the fitness of a policy solution for fiscal policy optimization.
   * 
   * @param solution The policy solution to evaluate
   * @param initialState The initial economic state
   * @param options Evaluation options
   * @returns The fitness result
   */
  const evaluate = async (
    solution: Record<string, any>,
    initialState: EconomicState,
    options: FitnessOptions = {}
  ): Promise<FitnessResult> => {
    // Implementation is similar to the previous functions, but focused on fiscal policy
    // For brevity, this is a simplified implementation
    
    return {
      fitness: 0.82, // Sample value
      normalizedFitness: 0.82,
      objectiveValues: {} as Record<EconomicMetric, number>,
      projectedState: initialState,
      shortTermEffects: {} as Record<EconomicMetric, number>,
      mediumTermEffects: {} as Record<EconomicMetric, number>,
      longTermEffects: {} as Record<EconomicMetric, number>,
      riskAnalysis: {
        downside: {} as Record<EconomicMetric, number>,
        upside: {} as Record<EconomicMetric, number>,
        volatility: {} as Record<EconomicMetric, number>
      },
      implementationFeasibility: 0.7,
      politicalFeasibility: 0.5,
      administrativeComplexity: 0.3,
      improvementOverBaseline: {} as Record<EconomicMetric, number>,
      tradeoffs: [],
      constraintViolations: [],
      log: ['Fiscal policy optimization evaluation completed']
    };
  };
  
  return {
    evaluate,
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => requiredParameters,
    getOptionalParameters: () => optionalParameters,
    getSupportedScenarios: () => supportedScenarios,
    getDefaultOptions: () => defaultOptions
  };
}

/**
 * Creates a new monetary policy optimization fitness function.
 * 
 * @returns Monetary policy optimization fitness function
 */
function createMonetaryPolicyOptimizationFunction(): EconomicFitnessFunction {
  const name = 'monetary_policy_optimization';
  const description = 'Evaluates policy effectiveness in optimizing monetary policy for price stability and sustainable growth';
  
  // Implementation details omitted for brevity
  return {
    evaluate: async () => ({ fitness: 0, normalizedFitness: 0, objectiveValues: {}, projectedState: {} as any, shortTermEffects: {}, mediumTermEffects: {}, longTermEffects: {}, riskAnalysis: { downside: {}, upside: {}, volatility: {} }, implementationFeasibility: 0, politicalFeasibility: 0, administrativeComplexity: 0, improvementOverBaseline: {}, tradeoffs: [], constraintViolations: [], log: [] }),
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => [],
    getOptionalParameters: () => [],
    getSupportedScenarios: () => [],
    getDefaultOptions: () => ({})
  };
}

/**
 * Creates a new inflation targeting fitness function.
 * 
 * @returns Inflation targeting fitness function
 */
function createInflationTargetingFunction(): EconomicFitnessFunction {
  const name = 'inflation_targeting';
  const description = 'Evaluates policy effectiveness in achieving target inflation rate';
  
  // Implementation details omitted for brevity
  return {
    evaluate: async () => ({ fitness: 0, normalizedFitness: 0, objectiveValues: {}, projectedState: {} as any, shortTermEffects: {}, mediumTermEffects: {}, longTermEffects: {}, riskAnalysis: { downside: {}, upside: {}, volatility: {} }, implementationFeasibility: 0, politicalFeasibility: 0, administrativeComplexity: 0, improvementOverBaseline: {}, tradeoffs: [], constraintViolations: [], log: [] }),
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => [],
    getOptionalParameters: () => [],
    getSupportedScenarios: () => [],
    getDefaultOptions: () => ({})
  };
}

/**
 * Creates a new labor market optimization fitness function.
 * 
 * @returns Labor market optimization fitness function
 */
function createLaborMarketOptimizationFunction(): EconomicFitnessFunction {
  const name = 'labor_market_optimization';
  const description = 'Evaluates policy effectiveness in optimizing labor market outcomes';
  
  // Implementation details omitted for brevity
  return {
    evaluate: async () => ({ fitness: 0, normalizedFitness: 0, objectiveValues: {}, projectedState: {} as any, shortTermEffects: {}, mediumTermEffects: {}, longTermEffects: {}, riskAnalysis: { downside: {}, upside: {}, volatility: {} }, implementationFeasibility: 0, politicalFeasibility: 0, administrativeComplexity: 0, improvementOverBaseline: {}, tradeoffs: [], constraintViolations: [], log: [] }),
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => [],
    getOptionalParameters: () => [],
    getSupportedScenarios: () => [],
    getDefaultOptions: () => ({})
  };
}

/**
 * Creates a new economic growth maximization fitness function.
 * 
 * @returns Economic growth maximization fitness function
 */
function createEconomicGrowthMaximizationFunction(): EconomicFitnessFunction {
  const name = 'economic_growth_maximization';
  const description = 'Evaluates policy effectiveness in maximizing sustainable economic growth';
  
  // Implementation details omitted for brevity
  return {
    evaluate: async () => ({ fitness: 0, normalizedFitness: 0, objectiveValues: {}, projectedState: {} as any, shortTermEffects: {}, mediumTermEffects: {}, longTermEffects: {}, riskAnalysis: { downside: {}, upside: {}, volatility: {} }, implementationFeasibility: 0, politicalFeasibility: 0, administrativeComplexity: 0, improvementOverBaseline: {}, tradeoffs: [], constraintViolations: [], log: [] }),
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => [],
    getOptionalParameters: () => [],
    getSupportedScenarios: () => [],
    getDefaultOptions: () => ({})
  };
}

/**
 * Creates a new supply shock resilience fitness function.
 * 
 * @returns Supply shock resilience fitness function
 */
function createSupplyShockResilienceFunction(): EconomicFitnessFunction {
  const name = 'supply_shock_resilience';
  const description = 'Evaluates policy effectiveness in building resilience to supply shocks';
  
  // Implementation details omitted for brevity
  return {
    evaluate: async () => ({ fitness: 0, normalizedFitness: 0, objectiveValues: {}, projectedState: {} as any, shortTermEffects: {}, mediumTermEffects: {}, longTermEffects: {}, riskAnalysis: { downside: {}, upside: {}, volatility: {} }, implementationFeasibility: 0, politicalFeasibility: 0, administrativeComplexity: 0, improvementOverBaseline: {}, tradeoffs: [], constraintViolations: [], log: [] }),
    getName: () => name,
    getDescription: () => description,
    getRequiredParameters: () => [],
    getOptionalParameters: () => [],
    getSupportedScenarios: () => [],
    getDefaultOptions: () => ({})
  };
}

/**
 * Helper function to calculate short-term effects of stagflation mitigation policies.
 * 
 * @param solution The policy solution
 * @param initialState The initial economic state
 * @param options Fitness options
 * @returns Short-term effects
 */
function calculateStagflationShortTermEffects(
  solution: Record<string, any>,
  initialState: EconomicState,
  options: FitnessOptions
): Record<string, number> {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  const commodityReserveRelease = solution.commodity_reserve_release || 0;
  
  // Effects of interest rate adjustment on inflation and growth
  const inflationEffect = -0.3 * interestRateAdjustment; // 1% increase reduces inflation by 0.3%
  const growthEffectFromMonetary = -0.2 * interestRateAdjustment; // 1% increase reduces growth by 0.2%
  
  // Effects of fiscal stimulus
  const growthEffectFromFiscal = 0.5 * fiscalStimulusPercentage; // 1% stimulus increases growth by 0.5%
  const inflationEffectFromFiscal = 0.1 * fiscalStimulusPercentage; // 1% stimulus increases inflation by 0.1%
  
  // Effects of supply-side reforms (minimal in short term)
  const growthEffectFromSupply = 0.05 * supplySideReformIntensity; // Small effect in short term
  const inflationEffectFromSupply = -0.05 * supplySideReformIntensity; // Small effect in short term
  
  // Effects of commodity reserve release
  const inflationEffectFromCommodity = -0.002 * commodityReserveRelease; // Reduces inflation slightly
  
  // Employment effects
  const unemploymentEffectFromMonetary = 0.1 * interestRateAdjustment; // Increases unemployment
  const unemploymentEffectFromFiscal = -0.2 * fiscalStimulusPercentage; // Decreases unemployment
  
  // Productivity effects
  const productivityEffectFromSupply = 0.01 * supplySideReformIntensity; // Small effect in short term
  
  // Capacity utilization effects
  const capacityUtilizationEffect = 
    0.5 * fiscalStimulusPercentage -
    0.3 * interestRateAdjustment +
    0.1 * supplySideReformIntensity;
  
  // Calculate combined effects
  return {
    gdpGrowth: initialState.gdpGrowth + growthEffectFromMonetary + growthEffectFromFiscal + growthEffectFromSupply,
    inflation: initialState.inflation + inflationEffect + inflationEffectFromFiscal + inflationEffectFromSupply + inflationEffectFromCommodity,
    unemployment: initialState.unemployment + unemploymentEffectFromMonetary + unemploymentEffectFromFiscal,
    productivityGrowth: initialState.productivityGrowth + productivityEffectFromSupply,
    capacityUtilization: Math.min(100, Math.max(0, initialState.capacityUtilization + capacityUtilizationEffect))
  };
}

/**
 * Helper function to calculate medium-term effects of stagflation mitigation policies.
 * 
 * @param solution The policy solution
 * @param initialState The initial economic state
 * @param shortTermEffects Short-term effects
 * @param options Fitness options
 * @returns Medium-term effects
 */
function calculateStagflationMediumTermEffects(
  solution: Record<string, any>,
  initialState: EconomicState,
  shortTermEffects: Record<string, number>,
  options: FitnessOptions
): Record<string, number> {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  
  // Interest rate effects normalize in medium term
  const inflationEffect = -0.5 * interestRateAdjustment; // Stronger effect in medium term
  const growthEffectFromMonetary = -0.1 * interestRateAdjustment; // Less negative as economy adjusts
  
  // Fiscal stimulus effects fade
  const growthEffectFromFiscal = 0.2 * fiscalStimulusPercentage; // Reduced effect
  const inflationEffectFromFiscal = 0.05 * fiscalStimulusPercentage; // Reduced effect
  
  // Supply-side reforms strengthen
  const growthEffectFromSupply = 0.2 * supplySideReformIntensity; // Stronger effect in medium term
  const inflationEffectFromSupply = -0.2 * supplySideReformIntensity; // Stronger effect in medium term
  
  // Employment effects
  const unemploymentEffectFromMonetary = 0.05 * interestRateAdjustment; // Reduced effect
  const unemploymentEffectFromFiscal = -0.1 * fiscalStimulusPercentage; // Reduced effect
  const unemploymentEffectFromSupply = -0.1 * supplySideReformIntensity; // Supply reforms improve employment
  
  // Productivity effects strengthen
  const productivityEffectFromSupply = 0.1 * supplySideReformIntensity; // Stronger effect in medium term
  
  // Calculate combined effects, building on short-term effects
  return {
    gdpGrowth: shortTermEffects.gdpGrowth + growthEffectFromMonetary + growthEffectFromFiscal + growthEffectFromSupply,
    inflation: shortTermEffects.inflation + inflationEffect + inflationEffectFromFiscal + inflationEffectFromSupply,
    unemployment: shortTermEffects.unemployment + unemploymentEffectFromMonetary + unemploymentEffectFromFiscal + unemploymentEffectFromSupply,
    productivityGrowth: shortTermEffects.productivityGrowth + productivityEffectFromSupply
  };
}

/**
 * Helper function to calculate long-term effects of stagflation mitigation policies.
 * 
 * @param solution The policy solution
 * @param initialState The initial economic state
 * @param mediumTermEffects Medium-term effects
 * @param options Fitness options
 * @returns Long-term effects
 */
function calculateStagflationLongTermEffects(
  solution: Record<string, any>,
  initialState: EconomicState,
  mediumTermEffects: Record<string, number>,
  options: FitnessOptions
): Record<string, number> {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  
  // In long term, monetary effects normalize
  const inflationEffect = 0; // Neutral in long term
  const growthEffectFromMonetary = 0; // Neutral in long term
  
  // Fiscal stimulus effects fade further
  const growthEffectFromFiscal = 0; // Minimal effect in long term
  const inflationEffectFromFiscal = 0; // Minimal effect in long term
  
  // Supply-side reforms dominate long term
  const growthEffectFromSupply = 0.3 * supplySideReformIntensity; // Strong effect in long term
  const inflationEffectFromSupply = -0.3 * supplySideReformIntensity; // Strong effect in long term
  
  // Long-term normalization of unemployment
  const unemploymentEffectTowardsNatural = 
    (options.modelParameters?.naturalUnemploymentRate || 4.5) - mediumTermEffects.unemployment;
  
  // Productivity effects strengthen further
  const productivityEffectFromSupply = 0.2 * supplySideReformIntensity; // Stronger effect in long term
  
  // Calculate combined effects, building on medium-term effects
  return {
    gdpGrowth: (options.modelParameters?.potentialGrowthRate || 2.0) + growthEffectFromSupply,
    inflation: (options.modelParameters?.inflationTarget || 2.0) + inflationEffectFromSupply,
    unemployment: mediumTermEffects.unemployment + 0.5 * unemploymentEffectTowardsNatural, // Partial movement towards natural rate
    productivityGrowth: mediumTermEffects.productivityGrowth + productivityEffectFromSupply
  };
}

/**
 * Helper function to get time horizon weights.
 * 
 * @param timeHorizon The time horizon
 * @returns Time horizon weights
 */
function getTimeHorizonWeights(timeHorizon: TimeHorizon): {
  shortTerm: number;
  mediumTerm: number;
  longTerm: number;
} {
  switch (timeHorizon) {
    case TimeHorizon.Immediate:
      return { shortTerm: 1.0, mediumTerm: 0.0, longTerm: 0.0 };
    case TimeHorizon.ShortTerm:
      return { shortTerm: 0.7, mediumTerm: 0.3, longTerm: 0.0 };
    case TimeHorizon.MediumTerm:
      return { shortTerm: 0.2, mediumTerm: 0.6, longTerm: 0.2 };
    case TimeHorizon.LongTerm:
      return { shortTerm: 0.1, mediumTerm: 0.3, longTerm: 0.6 };
    case TimeHorizon.VeryLongTerm:
      return { shortTerm: 0.0, mediumTerm: 0.2, longTerm: 0.8 };
    default:
      return { shortTerm: 0.2, mediumTerm: 0.6, longTerm: 0.2 };
  }
}

/**
 * Helper function to calculate implementation feasibility.
 * 
 * @param solution The policy solution
 * @param options Fitness options
 * @returns Implementation feasibility (0-1 scale)
 */
function calculateImplementationFeasibility(
  solution: Record<string, any>,
  options: FitnessOptions
): number {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  
  // Base feasibility
  let feasibility = 0.8;
  
  // Adjust for complexity of parameters
  if (Math.abs(interestRateAdjustment) > 2) {
    feasibility -= 0.1; // Large interest rate changes are harder
  }
  
  if (fiscalStimulusPercentage > 3) {
    feasibility -= 0.1; // Large fiscal stimuli are harder
  }
  
  if (supplySideReformIntensity > 6) {
    feasibility -= 0.2; // High-intensity reforms are much harder
  }
  
  // Adjust for consistency
  if (interestRateAdjustment > 0 && fiscalStimulusPercentage > 0) {
    feasibility -= 0.1; // Contradictory monetary and fiscal policies
  }
  
  return Math.max(0, Math.min(1, feasibility));
}

/**
 * Helper function to calculate political feasibility.
 * 
 * @param solution The policy solution
 * @param objectiveValues The objective values
 * @param options Fitness options
 * @returns Political feasibility (0-1 scale)
 */
function calculatePoliticalFeasibility(
  solution: Record<string, any>,
  objectiveValues: Record<EconomicMetric, number>,
  options: FitnessOptions
): number {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  
  // Base feasibility
  let feasibility = 0.7;
  
  // Adjust for unemployment impact (high unemployment reduces political feasibility)
  if (objectiveValues[EconomicMetric.Unemployment] > 8) {
    feasibility -= 0.2;
  } else if (objectiveValues[EconomicMetric.Unemployment] > 6) {
    feasibility -= 0.1;
  }
  
  // Adjust for growth impact (low growth reduces political feasibility)
  if (objectiveValues[EconomicMetric.GDPGrowth] < 1) {
    feasibility -= 0.1;
  } else if (objectiveValues[EconomicMetric.GDPGrowth] > 3) {
    feasibility += 0.1;
  }
  
  // Adjust for inflation impact (high inflation reduces political feasibility)
  if (objectiveValues[EconomicMetric.Inflation] > 5) {
    feasibility -= 0.1;
  }
  
  // Adjust for policy specifics
  if (interestRateAdjustment > 1) {
    feasibility -= 0.05; // Interest rate hikes are unpopular
  }
  
  if (fiscalStimulusPercentage > 0) {
    feasibility += 0.05; // Stimulus is usually popular
  }
  
  if (supplySideReformIntensity > 5) {
    feasibility -= 0.1; // Major reforms can face resistance
  }
  
  return Math.max(0, Math.min(1, feasibility));
}

/**
 * Helper function to calculate administrative complexity.
 * 
 * @param solution The policy solution
 * @param options Fitness options
 * @returns Administrative complexity (0-1 scale, lower is better)
 */
function calculateAdministrativeComplexity(
  solution: Record<string, any>,
  options: FitnessOptions
): number {
  // Extract solution parameters
  const interestRateAdjustment = solution.interest_rate_adjustment || 0;
  const fiscalStimulusPercentage = solution.fiscal_stimulus_percentage || 0;
  const supplySideReformIntensity = solution.supply_side_reform_intensity || 0;
  const targetedSectorCount = solution.targeted_sector_count || 0;
  
  // Base complexity
  let complexity = 0.3;
  
  // Adjust for policy specifics
  if (Math.abs(interestRateAdjustment) > 0) {
    complexity += 0.05; // Interest rate changes have some complexity
  }
  
  if (fiscalStimulusPercentage > 0) {
    complexity += 0.1; // Fiscal stimulus involves significant administration
  }
  
  if (supplySideReformIntensity > 0) {
    complexity += 0.1 * (supplySideReformIntensity / 10); // Reforms add complexity proportionally
  }
  
  if (targetedSectorCount > 0) {
    complexity += 0.05 * targetedSectorCount; // Each targeted sector adds complexity
  }
  
  return Math.max(0, Math.min(1, complexity));
}

// Export functions and classes
export {
  createStagflationMitigationFunction,
  createTradeBalanceOptimizationFunction,
  createFiscalPolicyOptimizationFunction,
  createMonetaryPolicyOptimizationFunction,
  createInflationTargetingFunction,
  createLaborMarketOptimizationFunction,
  createEconomicGrowthMaximizationFunction,
  createSupplyShockResilienceFunction
};